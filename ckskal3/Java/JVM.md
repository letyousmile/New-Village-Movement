## JVM 구성 및 동작
JVM 이란 자바 가상 머신으로 Java Byte Code 를 OS에 맞게 해석 해주는 역할을 한다. Java 파일을 컴파일러에 의해 ByteCode 형태인 class 파일로 변경하고, Jvm은 이 파일은 OS가 읽을 수 있는 형태로 재해석을 거친다. 이렇기에 다른 언어에 비해 속도가 느리다. 이런 문제를 해결하기 위해 JIT(Just In Time)컴파일러를 사용한다. 초기 jvm은 인터프린터방식(코드 한줄씩 읽고 실행)이였고, jit를 통해 보완(반복 사용되는 부분을 미리 네이티브 코드로 변경 한 후 다음에 사용될떄 인터프리터로 읽지 않고 미리 만들어 둔 네이티브 코드를 사용) 하였으며, 모든 코드를 jit로 하면 비용이 너무 크기에 일정 기준은 인터프린터방식을 사용하다 기준이 넘으면 jit를 사용한다. 
* 클래스로더
   * .class 파일을 메모리(Runtime Data Area)에 올리는 역할
* 런타임 데이터 에어리어

  프로그램을 수행하기 위해 os로 부터 할당 받은 메모리로, 5가지 공간으로 나눈다. 
   * pc register : 각 쓰레드마다 하나의 공간을 가지며, 각 쓰레드가 어떤 명령어를 실행하는지를 기록하며, 현재 수행중인 jvm명령의 주소를 갖는다.
   * jvm stack : 각 쓰레드마다 스택을 할당받으며, 메소드 프레임을 스택에 쌓으며 관리한다. 모든 작업이 끝난 메소드는 스택에서 빠진다.
   * native method stack : jvm stack 과 마찬가지로 쓰레드 별 스택을 할당 받으며 네이티브 방식의 메소드을 실행경우 이곳에 쌓이게 된다.ex) Thread.currentThread()
   * method area : 모든 쓰레드가 공유하는 메모리 영역, 클래스, 인터페이스, 메소드, 필드, static 변수등의 바이트 코드를 저장하는 공간
   * heap : 인스턴스를 저장하는 공간(Class class = new Calss();) gc의 처리 대상
* 익스큐션 
   * 클래스 로더에 의해 런타임 데이터 에어리어에 올라간 바이트 코드를 실행하는 역할