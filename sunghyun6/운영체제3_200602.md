# 운영체제

##### 동기와 비동기

- 동기적 -> 무슨 일을 순차적으로 진행하는 것
- 비동기적 -> 무슨 일을 동시에  진행하는 것
- 동기적이라는 것은 어떤 작업을 진행할 떄 LOCK 을 건다고 생각하면 편함

##### 프로세스 동기화

- 멀티 스레딩에서 언급했듯이, 동일한 자원을 동시에 접근하는 코드 영역을 Critical Section (임계영역)이라고 한다
- 임계영역 문제를 해결하기 위한 조건
  - 상호 배제 (Mutual Exclusion) - 프로세스 P1이 Critical Section 에서 실행중이면, 다른 프로세스들은 실행될 수 없다
  - 진행 (Progress) 진행중인 프로세스가 없고, 별도의 동작이 없는 프로세스들만 실행될 수 있다
  - Bounded Waiting(한정된 대기) P1가 Critical Section에 진입 신청 후 부터 받아들여질때까지, 다른 프로세스들이 Ciritical Section에 진입하는 횟수는 제한이 있어야 한다
- 해결책
  - LOCK
    - 어떤 프로세스가 임계영역에 진입할 때 LOCK을 획득하고 나갈때 반납하여 동시에 접근안되게 함
    - 단점 - 다중처리기 환경에서는 효율적이지 않다
  - Semaphores(세마포어)
    - 카운팅 세마포어 - 가용한 개수를 가진 자원에 대한 접근 제어용, 자원을 사용하면 감소하고 자원을 방출하면 증가
    - 이진 세마포어 - MUTEX 라고 부르며, 0과 1사이의 값만 가능함
    - 단점 - 바쁜 대기
      - 진입 코드를 계속 반복 실행해서 코드 상으로 낭비임
      - 재운 다음에 자리가 날 때 다시 꺠우는 방법으로 해결
    - 단점 - 교착상태
      - 둘 이상의 프로세스가 임계영역에 무한정 기다리고 있고, 임계영역에 있는 프로세스는 진입 대기중인 프로세스가 실행되어야 나갈 수 있음
  - 모니터
    - 공유 자원에 접근하기 위한 키 획득과 자원 사용 후 해제를 모두 처리한다.

##### 메모리 관리

- CPU 할당 시간이 끝난 프로세스의 메로리를 보조 기억장치로 내보내고, 다른 프로세스의 메모리를 불러 들이는 방식으로 관리 중임
- 단편화
  - 이 과정에서 단편화 문제가 발생하게 되는데, 적재되고 제거되는 일이 반복되다 보면 메모리 틈 사이에 사용하지 못할 작은 공간들이 일어나게 됨. 이것이 단편화
    - 외부 단편화: 메모리 공간 중 사용하지 못하게 되는 일부분들이 너무 많은 경우	
    - 내부 단편화: 프로 세스가 사용하는 메로리 공간에 포함된 남는 부분. 프로세스가 쓰는 건 9000인데 메모리가 10000이면 1000이 남는다
    - 압축 : 외부 단편화를 해결하기 위해 한곳으로 몰아버리고 메모리를 크게 하나로 합치는것 - 근데 너무 오래걸리고 비효율적임
- 페이징
  - 하나의 프로세스가 사용하는 메모리 공간이 연속저이었다는 제약을 없애는 것이 바로 페이징
  - 외부 단편화와 압축 작업을 해소하기 위한 방법! 물리 메모리는 Frame이라는 고정 크기로 분리되어 있고, 논리 메모리는 페이지라 불리는 고정 크기의 블록으로 분리된다(페이지 교체 알고리즘에 들어가는 페이지)
  - 페이징 기법을 사용하면, 논리 메모리는 물리 메모리에 저장될 떄 연속되어 저장될 필요가 없고 물리 메모리의 남는 프레임에 적절히 배치 - 외부 단편화 해결
  - 하나의 프로세스가 사용하는 공간은 여러개의 페이지로 나눠서 관리되고 (논리 메모리에서) 개별 페이지는 순서에 상관없이 물리 메모리에 있는 프레임에 매핑되어 저장된다.
    - 단점 : 내부 단편화 문제의 비중이 늘어남. 페이지 크기가 1024b 이고 프로세스 a가 3172 필요하면 100b가 남아서 4개의 페이지 프레임이 필요함, 그래서 내부 단편화가 발생
- 새그멘테이션
  - 페이징에서처럼 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌 서로 다른 크기의 논리적 단위인 세그먼트로 분할. 사용자가 두 개의 주소로 지정 세그먼트 테이블에는 각 세그먼트의 기준과 한계를 저장한다
    - 단점 : 서로 다른 크기의 세그먼트들이 메모리에 적재되고 제거되면 작은조각이 많이 남